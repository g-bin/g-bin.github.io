[{"title":"跨域","date":"2017-04-02T12:23:11.000Z","path":"2017/04/02/跨域/","text":"概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。 出于安全考虑，HTML的同源策略不允许JavaScript进行跨域操作，但是随着Web App的功能越来越强，对于跨域的需求也是与日俱增。 跨域大概分为两种： 第一种是xhr不能访问不同源的文档 第二种是不同window之间不能进行交互操作 跨域通信的方法大致可以分为两类 第一种是Hack，例如通过title，navigation等对象传递信息，最典型的就是JSONP。 第二类是HTML5支持，一个是Access-Control-Allow-Origin响应头，一个是window.postMessage。 一.设置 document.domain document.domain:获取/设置当前文档的原始域部分, 用于 同源策略. 在根域范围内，Mozilla允许你把domain属性的值设置为它的上一级域。例如，在 developer.mozilla.org 域内，可以把domain设置为 “mozilla.org” 但不能设置为 “mozilla.com” 或者”org”。 原理：相同主域名不同子域名下的页面可以设置document.domain利用他的特性让他们同域 限制： 同于document提供的是页面之间的相互操作，所以需要载入iframe页面； 只适用于父子window之间的通信，不能用于xhr； 只能在主域相同且子域不同的情况下使用。 举个栗子：在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。 12345678910document.domain = 'a.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.a.com/b.html';ifr.style.display = 'none';document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(\"h1\")[0].childNodes[0].nodeValue);&#125;; script.a.com上的b.html： 1document.domain = 'a.com'; 二：有src的标签 原理：所有具有src属性的html标签都是可以跨域的，比如img和script 限制：需要创建一个DOM对象，而且只能用于get方法 代表：JSONP 浏览器对XHR做了同源策略，但并没有将这种方式延续到script上（其实还有iframe，img等），从而可以利用动态script标签技术来做到跨域请求的作用 JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。 缺点：只能通过GET方式请求，一方面是参数长度有限制，二是安全性比较差； 需要服务器端的页面进行相应的配合的。 123456&lt;script type=\"text/javascript\"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src=\"http://example.com/data.php?callback=dosomething\"&gt;&lt;/script&gt; js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。 12345&lt;?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?&gt; 四：window.name window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置 优点： 利用了浏览器的特性来做到不同域之间的数据传递 不需要前后端配合 限制： 安全性不高，当前页面的所有window都可以修改 不同浏览器对于window.name的大小有限制 传递数据只能传递字符串 五：navigation对象 原理：iframe之间是共享navigator对象的，用它来传递信息 限制：只限于ie6/7 六：跨域资源共享（CORS） 原理： cors是一种通过设置前后端http header配置Access-Control-Allow-Origin来进行跨域的一种方式 限制： 浏览器需要支持HTML5，可以支持POST，PUT等方法 HTML5标准中提出的跨域资源共享（Cross Origin Resource Share，CORS）才是正道。 它支持其他的HTTP方法如PUT, POST等，可以从本质上解决跨域问题比如我们要从http://a.com访问http://b.com我们可以直接在b.com的服务器中设置相应字段 12Access-Control-Allow-Origin: * # 允许所有域名访问，或者Access-Control-Allow-Origin: http://a.com # 只允许特定域名访问 七：window.postMessage 原理： HTML5允许窗口之间发送消息 限制： 浏览器需要支持HTML5，获取窗口句柄后才能相互通信 12345678// URL: http://a.com/foovar win = window.open('http://b.com/bar');win.postMessage('Hello, bar!', 'http://b.com'); // URL: http://b.com/barwindow.addEventListener('message',function(event) &#123; console.log(event.data);&#125;);","tags":[]},{"title":"js碎笔记","date":"2017-03-13T08:43:46.000Z","path":"2017/03/13/碎笔记/","text":"函数名字不可改。 访问原型对象： 构造函数：f.prototype 实例: obj. proto ; Object.getPrototypeof(obj) 判断数据类型： typeof 变量 复杂数据类型返回Object; 注意： console.log(typeof null);//Object console.log(null instanceof Object);//false 函数返回Function; undefined返回undefined null == undefined //true null ==== undefined //false in关键字作用 检测属性：属性名 in 对象 遍历对象 for(var key in obj){key,obj[key]} 遍历数组 for(var key in arr){key指的是索引} 相等操作符 == 123456var str = 'demo';var strObj = new String('demo');console.log(typeof str); //stringconsole.log(typeof strObj); // objectconsole.log(str == strObj); //trueconsole.log(str === strObj); //false 相等的原因：==操作符如果有一边是对象另一边不是，那对象就会调用对象的valueof方法用得到的基本类型值再去比较","tags":[{"name":"碎笔记","slug":"碎笔记","permalink":"http://yoursite.com/tags/碎笔记/"}]},{"title":"闭包","date":"2017-03-12T07:46:37.000Z","path":"2017/03/12/闭包/","text":"闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点 一：变量的作用域 变量的作用域，就是指变量的有效范围。我们最常谈到的是在函数中声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var，这个变量就会成为全局变量，这当然是一种容易造成命名冲突的做法。 另外一种情况是用 var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。 123456789101112var a = 1; var func1 = function()&#123; var b = 2; var func2 = function()&#123; var c = 3; alert ( b ); // 输出： 2 alert ( a ); // 输出： 1 &#125; func2(); alert ( c ); // 输出： Uncaught ReferenceError: c is not defined &#125;;func1(); 注意：在 JavaScript 中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的 二：变量的生存周期 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。 但是因为有闭包的存在却产生了很多奇妙的事情，小伙伴们看下面的情形： 1：假设页面上有 5 个div 节点，我们通过循环来给每个 div 绑定 onclick 事件，按照索引顺序，点击第 1 个 div 时弹出0，点击第 2 个 div 时弹出 1，以此类推，你会怎么做呢？ 1234567891011121314151617&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;script&gt; var nodes = document.getElementsByTagName( 'div' ); for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; nodes[ i ].onclick = function()&#123; alert ( i ); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 你是不是这么想的？嗯哼~ 厉害了，不过错了，啦啦啦， 测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的onclick 事件是被异步触发的，当事件被触发的时候， for 循环早已结束，此时变量 i 的值已经是5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。 那怎么办呢？闭包呀，吃包子喽！ 1234567for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)( i )&#125;; 三：闭包的更多形式和作用小闭包形式： 1.()() 2.;()() 3.+()() 4.-()() 目的：全局变量私有化 优点： 1.不污染全局变量 2.内部的临时变量执行完毕都会释放，不会占据内存 3.避免使用全局变量 4.更新复杂变量 1.封装变量 计算乘积 1234567891011121314var mult = (function()&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call( arguments, ',' ); if ( args in cache )&#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ )&#123; a = a * arguments[i]; &#125; return cache[ args ] = a; &#125;&#125;)(); 小伙伴们可看出什么猫腻？对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以像上面那样加入缓存机制来提高这个函数的性能，是不是很机智呢？ 补充点 1234567891011var Type = &#123;&#125;; for ( var i = 0, type; type = [ 'String', 'Array', 'Number' ][ i++ ]; )&#123;//i++到3的时候type为undefined，结束循环 (function( type )&#123; Type[ 'is' + type ] = function( obj )&#123; return Object.prototype.toString.call( obj ) === '[object '+ type +']'; &#125; &#125;)( type ) &#125;; console.log(Type.isArray([])); console.log(Type.isString(\"str\")); console.log(undefined == false);//false 反正我觉得很好玩，哈哈。 2.延续局部变量的寿命，并读取 引用循环变量，如下所示： 1234567891011121314function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 小伙伴们看这个有什么感触么？调用f1,f2,f3会有什么结果呢？是的，结果往往那么不如人意~~~ f1(); // 16 f2(); // 16 f3(); // 16 Why?原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用，那么又要小包子上场了方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 img 对象经常用于进行数据上报，如下所示： 12345var report = function( src )&#123; var img = new Image(); img.src = src;&#125;;report( 'http://xxx.com/getUserInfo' ); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说， report 函数并不是每一次都成功发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。 现在我们把img 变量用闭包封闭起来，便能解决请求丢失的问题： 12345678var report = (function()&#123; var imgs = []; return function( src )&#123; var img = new Image(); imgs.push( img ); img.src = src;&#125;&#125;)(); 3.高级排他123456789101112131415window.onload = function()&#123; var ul = document.getElementById('ul'); var lis = ul.children; var lastOne = 0; for(var i =0; i &lt; lis.length;i++)&#123; (function (index) &#123; lis[i].onmouseover = function () &#123; lis[lastOne].className = ''; this.className = 'current'; lastOne = index &#125; &#125;)(i) &#125;&#125; 每次移动把之前的样式清除，再把当前的设置样式，再次重置初始值。此处还要注意js执行任务的顺序 4.函数节流 使用场景 window.onresize 事件。 我们给 window 对象绑定了 resize 事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果我们在 window.onresize 事件函数里有一些跟 DOM 节点相关的操作，而跟 DOM 节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。 mousemove 事件。 如果我们给一个 div 节点绑定了拖曳事件（主要是 mousemove） ，当div 节点被拖动的时候，也会频繁地触发该拖曳事件函数。 上传进度。 微云的上传功能使用了公司提供的一个浏览器插件。该浏览器插件在真正开始上传文件之前，会对文件进行扫描并随时通知 JavaScript 函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，大约一秒钟 10 次，很显然我们在页面中不需要如此频繁地去提示用户 第一种 1234567891011121314151617181920212223242526function throttle(fn, interval) &#123; var timeoutID = null, //保存需要被延迟执行的函数引用 firstTime = true; // 是否是第一次调用 return function () &#123; var self = this; //保存函数的运行环境 console.log(self); var args = arguments; if (firstTime) &#123;// 如果是第一次调用，不需延迟执行 fn.apply(this, args); firstTime = false return; &#125; if (timeoutID) &#123; // 如果定时器还在，说明前一次延迟执行还没有完成 return; &#125; timeoutID = setTimeout(function () &#123; // 延迟一段时间执行 clearTimeout(timeoutID); timeoutID = null; fn.apply(self, args) &#125;, interval || 500); &#125; &#125; // 这里的意思是window对象上的方法onresize的值是throttle的返回值，所以返回值里面的this指向的是window这个对象，如果是div，onmousemove的话那this就是指向的div了，但是因为闭包返回的函数中的this指向window，所以为了保证this一直是window才用self保存了this从而保存了throttle返回函数的运行环境 window.onresize = throttle(function () &#123; console.log(1); &#125;, 500); 四：闭包和面向对象设计过程与数据的结合是形容面向对象中的“对象”时经常使用的表达 闭包方式 12345678910var extent = function()&#123; var value = 0; return &#123; call: function()&#123; value++; console.log( value ); &#125; &#125;&#125;;var extent = extent(); 面向对象方式 1234567891011var Extent = function()&#123; this.value = 0;&#125;;Extent.prototype.call = function()&#123; this.value++; console.log( this.value );&#125;;var extent = new Extent();extent.call();extent.call();extent.call(); 五：用闭包实现命令模式 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。 在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来； 在闭包版本的命令模式中，命令接收者会被封闭在闭包形成的环境中。 面向对象版本 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;body&gt;&lt;button id=\"execute\"&gt;点击我执行命令&lt;/button&gt;&lt;button id=\"undo\"&gt;点击我执行命令&lt;/button&gt;&lt;script&gt; var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125; &#125;; var OpenTvCommand = function( receiver )&#123; this.receiver = receiver; &#125;; OpenTvCommand.prototype.execute = function()&#123; this.receiver.open(); // 执行命令，打开电视机 &#125;; OpenTvCommand.prototype.undo = function()&#123; this.receiver.close(); // 撤销命令，关闭电视机 &#125;; var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125; &#125;; setCommand( new OpenTvCommand( Tv ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包版本 1234567891011121314151617181920212223242526272829var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125; &#125;; var createCommand = function( receiver )&#123; var execute = function()&#123; return receiver.open(); // 执行命令，打开电视机 &#125; var undo = function()&#123; return receiver.close(); // 执行命令，关闭电视机 &#125; return &#123; execute: execute, undo: undo &#125; &#125;; var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125; &#125;; setCommand( createCommand( Tv ) ); 六：闭包与内存管理 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。 使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。 在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 ok，收工！","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"this","date":"2017-03-02T12:57:53.000Z","path":"2017/03/02/this/","text":"this是Javascript语言的一个关键字 使用场景注意点：在绝大多数情况下，函数的调用方式决定了this的值。this不能在执行期间被赋值，在每次函数被调用时this的值也可能会不同 全局环境 在全局运行上下文（全局环境）中（在任何函数体外部），this指代全局对象，无论是否在严格模式下 1234// 在浏览器中，全局对象为 window 对象：console.log(this === window); // truethis.a = 37;console.log(window.a); // 37 函数上下文 在函数内部，this的值取决于函数是如何调用的。 1. 直接调用时的this 因为下面的代码不是在严格模式下执行，并且this的值不会在函数执行时被设置，此时的this的值会默认设置为全局对象 1234function f1()&#123; return this;&#125;f1() === window; // true 然而，在严格模式下，this将保持他进入执行环境时的值，所以下面的this将会默认为undefined 12345function f2()&#123; \"use strict\"; // 这里是严格模式 return this;&#125;f2() === undefined; // true 注意：在严格模式下，如果this未被执行的上下文环境定义，那么它将会默认为undefined。 2. 对象方法中的this 当以对象里的方法的方式调用函数时，它们的 this 是调用该函数的对象. 1234567var o = &#123;prop: 37&#125;;function independent() &#123; return this.prop;&#125;o.f = independent;console.log(o.f()); // logs 37 注意，在何处或者如何定义调用函数完全不会影响到this的行为,this的值只与函数作为对象的成员被调用有关系 3. 构造函数中的this 当一个函数被当做构造函数来调用的时候（首字母大写，与new一起使用），他的this与即将创建的新对象绑定。 12345function C2()&#123; this.a = 37;&#125;o = new C2();console.log(o.a); // logs 37 但是要小心下面的情况 123456function C2()&#123; this.a = 37; return &#123;a:38&#125;;&#125;o = new C2();console.log(o.a); // logs 38 注意：当构造函数返回一个引用类型的时候，与this绑定的默认对象被取消，也就是说返回的值会覆盖原先的新对象 4. call和apply中的this 当一个函数的函数体内部使用了this，然后通过所有的函数都继承了Function对象的原型上的call()和apply()方法调用的时候可以改变this的指向为call和apply方法的第一个参数，如下： 123456789 var x = 0; function test(y,z)&#123; console.log(this.x + y + z); &#125; var obj = &#123; x:3 &#125; test.call(obj,4,5)//test.apply(obj,[4,5]) 注意点：在使用call和apply的时候如果第一个参数传递的不是一个对象，那么JavaScript会在内部使用ToObject将其转换为对象，比如原始值是7的话，内部就会通过new Number(7)来把他转换为一个对象，如下： 1234function bar() &#123; console.log(Object.prototype.toString.call(this));&#125;bar.call(7); // [object Number] 5. bind中的this 如果调用fn.bind(obj)方法的话会创建一个和fn有相同函数体和作用域的新函数，但是这个新函数的this被绑定为了第一个参数obj，而且不管他是怎么调用 1234567function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:\"azerty\"&#125;);console.log(g());//azertyvar o = &#123;a:37, f:f, g:g&#125;;console.log(o.f(), o.g()); //37 azerty 扩充：实现bind 12345678910111213141516171819 Function.prototype.bind = function () &#123; var that = this;// 绑定时候传入的参数 var argu = [].slice.call(arguments);// 需要固定已经传入的参数 var param = argu.slice(1)// 返回的新函数 return function () &#123; that.apply(argu[0],param.concat([].slice.call(arguments))) &#125; &#125; var obj =&#123; name:'ll', show: function (a,b,c,d,e,f) &#123; console.log([a,b,c,d,e,f]); &#125; &#125; var w = obj.show.bind(obj,1,2,3,4); w(5,6,7) 6. DOM事件处理函数中的this 当函数被用作事件处理函数时候，this指向的是触发事件的元素，在一些不是用addEventListener动态添加事件的浏览器中不遵守这个约定 12345678910111213// 被调用时，将关联的元素变成蓝色function bluify(e)&#123; console.log(this === e.currentTarget); // 总是 true // 当 currentTarget 和 target 是同一个对象是为 true console.log(this === e.target); this.style.backgroundColor = '#A5D9F3';&#125;// 获取文档中的所有元素的列表var elements = document.getElementsByTagName('div');// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色for(var i=0 ; i&lt;elements.length ; i++)&#123; elements[i].addEventListener('click', bluify, false);&#125; 7. 定时器中的this 定时器中回调函数里面的this指向全局window 8. this的备份 当使用多层this时候，为了访问正确的this我们需要对正确的this进行备份，以便后来使用 1234567891011var o = &#123; f1: function () &#123; console.log(this); var f2 = function () &#123; console.log(this); &#125;(); &#125;&#125;o.f1()// Object// Window 是不是和你想要的不太一样呢？你或许更想要下面这样的呢 123456789101112 var o = &#123; f1: function() &#123; console.log(this); var that = this; var f2 = function() &#123; console.log(that); &#125;(); &#125;&#125;o.f1()// Object// Object 以上的代码中用变量that保存了函数外部的this，然后在函数内部使用that就不会发生this指向错乱的情况了 数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部的this指向的还是window 123456789101112var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + ' ' + item); &#125;); &#125;&#125;o.f()// undefined a1// undefined a2 解决方案一：this的备份 12345678910111213var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; var that = this; this.p.forEach(function (item) &#123; console.log(that.v+' '+item); &#125;); &#125;&#125;o.f()// hello a1// hello a2 解决方案二：将this当作foreach方法的第二个参数，固定它的运行环境。 123456789101112var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + ' ' + item); &#125;, this); &#125;&#125;o.f()// hello a1// hello a2 9. Node中的this 在Node中，this的指向又分成两种情况。全局环境中，this指向全局对象global；模块环境中，this指向module.exports。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"DOM","date":"2015-03-19T08:24:35.000Z","path":"2015/03/19/DOM/","text":"一：基本概念1.DOM 文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口，DOM 提供了一种表述形式— 将文档作为一个结构化的节点组以及包含属性和方法的对象。从本质上说，它将 web 页面和脚本或编程语言连接起来了。 2.节点 DOM的最小组成单位叫节点(node)，文档的树形结构(DOM树)就是由不同类型的节点组成的。 节点类型如下 Document：整个文档树的顶层节点 DocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;） Element：网页的各种HTML标签（比如&lt;body&gt;、&lt;a&gt;等） Attribute：网页元素的属性（比如class=”right”） Text：标签之间或标签包含的文本 Comment：注释 DocumentFragment：文档的片段 这七种节点都属于浏览器原生提供的节点对象的派生对象，具有一些共同的属性和方法 3.节点树 一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是DOM。 最顶层的节点就是document节点，它代表了整个文档。文档里面最高一层的HTML标签，一般是，它构成树结构的根节点（root node），其他HTML标签节点都是它的下级。 除了根节点以外，其他节点对于周围的节点都存在三种关系。 父节点关系（parentNode）：直接的那个上级节点 子节点关系（childNodes）：直接的下级节点 同级节点关系（sibling）：拥有同一个父节点的节点 二：特征相关的属性 所有的节点对象都是浏览器内置对象node的实例，继承了Node属性和方法，这是所有节点的共同特征，以下属性与节点对象本身的特征相关 1.Node.nodeName，Node.nodeType nodeName属性返回节点的名称，nodeType属性返回节点类型的常数值 类型 nodeName nodeType ELEMENT_NODE 大写的HTML元素名 1 ATTRIBUTE_NODE 等同于Attr.name 2 TEXT_NODE #text 3 COMMENT_NODE #comment 8 DOCUMENT_NODE #document 9 DOCUMENT_FRAGMENT_NODE #document-fragment 11 DOCUMENT_TYPE_NODE 等同于DocumentType.name 10 举个栗子：123var box = document.querySelector('.box');console.log(box.nodeName);//DIVconsole.log(box.nodeType);//1 2.Node.nodeValue Node.nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。 由于只有Text节点、Comment节点、XML文档的CDATA节点有文本值，因此只有这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这三类节点可以设置nodeValue属性的值。对于那些返回null的节点，设置nodeValue属性是无效的。 3.Node.textContent Node.textContent属性返回当前节点和它的所有后代节点的文本内容 1234567&lt;body&gt;&lt;div class=\"box\"&gt; 我是个盒子啊 &lt;span&gt;啦啦啦&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;console.log(box.textContent);//我是个盒子啊 啦啦啦 注意点： document节点和doctype节点的textContent属性为null。 如果要读取整个文档的内容，可以使用document.documentElement.textContent。 4.Node.baseURI Node.baseURI属性返回一个字符串，表示当前网页的绝对路径。如果无法取到这个值，则返回null。浏览器根据这个属性，计算网页上的相对路径的URL。该属性为只读。 该属性的值一般由当前网址的URL（即window.location属性）决定，但是可以使用HTML的标签，改变该属性的值。&lt;base href=&quot;http://www.example.com/page.html&quot;&gt; &lt;base target=&quot;_blank&quot; href=&quot;http://www.example.com/page.html&quot;&gt;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]