[{"title":"小心情","date":"2017-03-13T07:44:09.000Z","path":"2017/03/13/小心情/","text":"啦啦啦，我是落落啊！","tags":[{"name":"tags1","slug":"tags1","permalink":"http://yoursite.com/tags/tags1/"},{"name":"tags2","slug":"tags2","permalink":"http://yoursite.com/tags/tags2/"}]},{"title":"this","date":"2017-03-12T12:57:53.000Z","path":"2017/03/12/this/","text":"这是this","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"闭包","date":"2017-03-12T07:46:37.000Z","path":"2017/03/12/闭包/","text":"闭包闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点 一：变量的作用域 变量的作用域，就是指变量的有效范围。我们最常谈到的是在函数中声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var，这个变量就会成为全局变量，这当然是一种容易造成命名冲突的做法。 另外一种情况是用 var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。 123456789101112var a = 1; var func1 = function()&#123; var b = 2; var func2 = function()&#123; var c = 3; alert ( b ); // 输出： 2 alert ( a ); // 输出： 1 &#125; func2(); alert ( c ); // 输出： Uncaught ReferenceError: c is not defined &#125;;func1(); 注意：在 JavaScript 中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的 二：变量的生存周期 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。 但是因为有闭包的存在却产生了很多奇妙的事情，小伙伴们看下面的情形： 1：假设页面上有 5 个div 节点，我们通过循环来给每个 div 绑定 onclick 事件，按照索引顺序，点击第 1 个 div 时弹出0，点击第 2 个 div 时弹出 1，以此类推，你会怎么做呢？ 1234567891011121314151617&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;script&gt; var nodes = document.getElementsByTagName( 'div' ); for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; nodes[ i ].onclick = function()&#123; alert ( i ); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 你是不是这么想的？嗯哼~ 厉害了，不过错了，啦啦啦， 测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的onclick 事件是被异步触发的，当事件被触发的时候， for 循环早已结束，此时变量 i 的值已经是5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。 那怎么办呢？闭包呀，吃包子喽！ 1234567for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)( i )&#125;; 三：闭包的更多形式和作用小闭包形式： 1.()() 2.;()() 3.+()() 4.-()() 目的：全局变量私有化 优点： 1.不污染全局变量 2.内部的临时变量执行完毕都会释放，不会占据内存 3.避免使用全局变量 4.更新复杂变量 1.封装变量 计算乘积 1234567891011121314var mult = (function()&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call( arguments, ',' ); if ( args in cache )&#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ )&#123; a = a * arguments[i]; &#125; return cache[ args ] = a; &#125;&#125;)(); 小伙伴们可看出什么猫腻？对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以像上面那样加入缓存机制来提高这个函数的性能，是不是很机智呢？ 补充点 1234567891011var Type = &#123;&#125;; for ( var i = 0, type; type = [ 'String', 'Array', 'Number' ][ i++ ]; )&#123;//i++到3的时候type为undefined，结束循环 (function( type )&#123; Type[ 'is' + type ] = function( obj )&#123; return Object.prototype.toString.call( obj ) === '[object '+ type +']'; &#125; &#125;)( type ) &#125;; console.log(Type.isArray([])); console.log(Type.isString(\"str\")); console.log(undefined == false);//false 反正我觉得很好玩，哈哈。 2.延续局部变量的寿命，并读取 引用循环变量，如下所示： 1234567891011121314function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 小伙伴们看这个有什么感触么？调用f1,f2,f3会有什么结果呢？是的，结果往往那么不如人意~~~ f1(); // 16 f2(); // 16 f3(); // 16 Why?原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用，那么又要小包子上场了方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 img 对象经常用于进行数据上报，如下所示： 12345var report = function( src )&#123; var img = new Image(); img.src = src;&#125;;report( 'http://xxx.com/getUserInfo' ); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说， report 函数并不是每一次都成功发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。 现在我们把img 变量用闭包封闭起来，便能解决请求丢失的问题： 12345678var report = (function()&#123; var imgs = []; return function( src )&#123; var img = new Image(); imgs.push( img ); img.src = src;&#125;&#125;)(); 3.高级排他123456789101112131415window.onload = function()&#123; var ul = document.getElementById('ul'); var lis = ul.children; var lastOne = 0; for(var i =0; i &lt; lis.length;i++)&#123; (function (index) &#123; lis[i].onmouseover = function () &#123; lis[lastOne].className = ''; this.className = 'current'; lastOne = index &#125; &#125;)(i) &#125;&#125; 每次移动把之前的样式清除，再把当前的设置样式，再次重置初始值。此处还要注意js执行任务的顺序 4.函数节流 使用场景 window.onresize 事件。 我们给 window 对象绑定了 resize 事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果我们在 window.onresize 事件函数里有一些跟 DOM 节点相关的操作，而跟 DOM 节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。 mousemove 事件。 如果我们给一个 div 节点绑定了拖曳事件（主要是 mousemove） ，当div 节点被拖动的时候，也会频繁地触发该拖曳事件函数。 上传进度。 微云的上传功能使用了公司提供的一个浏览器插件。该浏览器插件在真正开始上传文件之前，会对文件进行扫描并随时通知 JavaScript 函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，大约一秒钟 10 次，很显然我们在页面中不需要如此频繁地去提示用户 第一种 12345678910function throttle(fn,delay)&#123; var timer = null; return function () &#123; clearTimeout(timer); setTimeout(fn,delay); &#125;&#125;;window.onscroll = throttle(function()&#123; console.log('函数节流');&#125;, 200); 第二种 123456789101112131415161718192021222324var throttle = function ( fn, interval ) &#123; var __self = fn, // 保存需要被延迟执行的函数引用 timer, // 定时器 firstTime = true; // 是否是第一次调用 return function () &#123; var args = arguments, __me = this; if ( firstTime ) &#123; // 如果是第一次调用，不需延迟执行 __self.apply(__me, args); return firstTime = false; &#125; if ( timer ) &#123; // 如果定时器还在，说明前一次延迟执行还没有完成 return false; &#125; timer = setTimeout(function () &#123; // 延迟一段时间执行 clearTimeout(timer); timer = null; __self.apply(__me, args); &#125;, interval || 500 ); &#125;; &#125;; window.onresize = throttle(function()&#123; console.log( 1 ); &#125;, 500 ); 四：闭包和面向对象设计过程与数据的结合是形容面向对象中的“对象”时经常使用的表达 闭包方式 12345678910var extent = function()&#123; var value = 0; return &#123; call: function()&#123; value++; console.log( value ); &#125; &#125;&#125;;var extent = extent(); 面向对象方式 1234567891011var Extent = function()&#123; this.value = 0;&#125;;Extent.prototype.call = function()&#123; this.value++; console.log( this.value );&#125;;var extent = new Extent();extent.call();extent.call();extent.call(); 五：用闭包实现命令模式 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。 在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来； 在闭包版本的命令模式中，命令接收者会被封闭在闭包形成的环境中。 面向对象版本 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;body&gt;&lt;button id=\"execute\"&gt;点击我执行命令&lt;/button&gt;&lt;button id=\"undo\"&gt;点击我执行命令&lt;/button&gt;&lt;script&gt; var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125; &#125;; var OpenTvCommand = function( receiver )&#123; this.receiver = receiver; &#125;; OpenTvCommand.prototype.execute = function()&#123; this.receiver.open(); // 执行命令，打开电视机 &#125;; OpenTvCommand.prototype.undo = function()&#123; this.receiver.close(); // 撤销命令，关闭电视机 &#125;; var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125; &#125;; setCommand( new OpenTvCommand( Tv ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包版本 1234567891011121314151617181920212223242526272829var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125; &#125;; var createCommand = function( receiver )&#123; var execute = function()&#123; return receiver.open(); // 执行命令，打开电视机 &#125; var undo = function()&#123; return receiver.close(); // 执行命令，关闭电视机 &#125; return &#123; execute: execute, undo: undo &#125; &#125;; var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125; &#125;; setCommand( createCommand( Tv ) ); 六：闭包与内存管理 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。 使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。 在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 ok，收工！","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]